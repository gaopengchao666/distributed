BIO:  同步阻塞IO模型，默认情况下服务端每接收一个客户端请求，都需要创建一个线程，该线程去阻塞处理IO操作，不能处理别的事情。
      BIO是面向流的，每次从流中读取数据不会有任何缓存，也不能前后移动流中的数据。当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了
	  BIO可靠性比较差，系统吞吐量比较低。

NIO: 同步非阻塞IO模型，NIO是面向缓冲区的，可以实现对前后读写数据的移动。
	所谓非阻塞，当我们的进程访问我们的数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。如果数据已经
准备好，也直接返回。也就是创建连接、输入流、输出流、关闭连接本来串行操作可以并行去做。
    NIO的触发方式是选择器轮训，创建连接、输入流、输出流都可以认为是一个selectKey, 当处理完成一个key会继续处理下一个，用一个有限的线程池满足大批量的用户请求，无序每个请求创建一个线程。也不用等待线程执行完读写请求。
	NIO可靠性比较高，系统吞吐量高。

AIO：异步非阻塞IO模型，继续事件模型处理客户端请求，客户端发起请求，不管是否处理完成，已经结束不用阻塞，客户端也无需轮训查看请求处理情况，当服务端请求处理完成时，通过事件通知，客户端完成数据的读写。


BIO好比老板想去银行取钱，自己跑到银行柜台，并且很长的阻塞队伍等待取钱，等待过程中不能离开做其他事情。
NIO好比老板去银行取钱，去银行大厅抽个号，坐到等候区，可以做别的事情，每个一会问一下大堂经理有没有轮到他，无序阻塞在排队中，但是取钱这个动作得同步完成。

AIO好比老板想取点钱，直接告诉小李账户名密码去帮我取，自己什么都不用管，等小李取好钱，直接交给老板就行了。